---
title: "A Key-Management Scheme for Distributed Sensor Networks"
date: 2025-04-02
categories: [Security]
tags: [key, 노드]
mathjax: true
---
## #1. 논문요약

**분산 센서 네트워크(DSN)의 보안 문제를 해결하기 위해, 확률적 키 공유 기반의 경량 키 관리 기법 제안**

- 기존 키 분배 방식의 한계를 해결하기 위해, **무작위 키 풀에서 선택된 키링(key ring)**을 각 노드에 사전 분배
- 이후 **공유키 발견 → 경로키 설정 → 키 폐기/재분배**, 각 단계를 단순한 연산으로 수행
- **DSN 특유의 동적 노드 추가/삭제, 보안성 요구, 자원 제약** 조건을 충족
- 시뮬레이션과 이론 분석을 통해 **보안성과 네트워크 연결성** 모두 확보 가능함을 증명

→ **“센서 노드 자원 제약 및 보안 위협 환경에서 확률 기반 키 사전 분배 기법으로 안전하고 유연한 키 관리 실현”**

## #2. 주요용어 설명

- **DSN (Distributed Sensor Network)**
    
    수천 개 이상 센서 노드가 무선으로 연결된 네트워크. 센서들은 **자원 제약 심함(메모리, 연산, 배터리)**
    
    일부 노드는 동적으로 추가/삭제 가능, **노드 물리적 공격 가능성 높음**
    
    ---
    
- **키 관리(Key Management)**
    
    네트워크 내 노드 간 안전한 통신을 위해 **암호키 분배, 갱신, 폐기** 등 수행.
    
     DSN에서는 자원 제약으로 인해 **공개키 방식 可X**, 대칭키 방식 필요
    
    ---
    
- **키 사전 분배(Key Pre-distribution)**
    
    네트워크 배포 전 각 노드에 **암호키를 미리 저장**. 이후, 노드 간 **공유 키 발견 및 경로 키 설정** 수행
    
    ---
    
- **Key Ring (키링)**
    
    한 노드에 저장된 키들의 집합. 논문에서는 키 풀(P)에서 무작위로 k개 선택해 구성됨
    
    ---
    
- **Random Graph (무작위 그래프)**
    
    노드 쌍 사이 연결 확률 p 기반으로 그래프 생성. **노드 연결성 분석**에 사용됨
    
    ---
    
- **Shared-Key Discovery**
    
    인접한 노드 간 **공통 키가 있는지 확인**. 연결 가능 시 안전 통신 가능
    
    ---
    
- **Path-Key Establishment**
    
    직접 공유 키가 없는 경우, **중간 노드를 통해 간접 경로 설정**하여 키를 공유
    
    ---
    
- **경로 키 (Path Key)**
    
    공유 키가 없는 노드 간, 중간 노드를 통해 안전하게 설정되는 일회성 키
    
    ---
    
- **노드 캡처 (Node Capture)**
    
    공격자가 물리적으로 센서를 확보하고 내부 저장 키를 추출하는 공격
    

## #3. 선행연구 분석

- **기존 방법들의 문제점**
    - **단일 미션 키 방식**: 하나의 키를 모든 노드에 저장 → 한 노드 노출 시 전체 네트워크 위험
    - **모든 노드 간 개별 키 저장 방식**: 각 노드가 다른 모든 노드와의 개별 키를 저장 →저장 공간이 비현실적으로 크며, 재키잉·노드 추가/삭제 시 비용 증가.
- **대칭키 기반 그룹 통신 연구 [1][2]**
    - 그룹 멤버 간 키 공유를 다루나, **센서 노드의 메모리 제약 고려 無**
- **브로드캐스트 암호화 연구 [4]**
    - 마스터-슬레이브 구조 기반 → 대규모 DSN에 **확장성 문제**
- ✅ 본 논문은 **저장 용량 제한 고려 + 확률적 방식 도입 + 무작위 그래프 이론 결합**
    
    → **보안성과 연결성**을 동시에 확보하는 실용적 대안 제시
    

## #4. 핵심 아이디어 및 기여점: 확률적 키 사전분배 기반 관리

자원이 제한된 센서 네트워크를 위해, 키를 무작위로 분배하고 간접 연결을 허용하는 방식으로, 효율성과 보안성을 동시에 확보하는 키 관리 체계를 제안.

📌 **문제 배경**

- **센서 네트워크의 특성**
    - 수천~수만 개의 작은 센서들이 무선으로 연결됨.
    - 각 센서는 계산 능력, 저장 공간, 전력이 매우 제한됨.
    - 언제든 센서가 추가되거나 사라질 수 있음.
    - 외부 공격자가 센서를 훔치거나 내부 정보를 탈취할 수 있음.
- **보안 통신의 필요성**
    - 센서 간의 모든 통신은 암호화되어야 하며, 탈취된 센서는 네트워크에서 즉시 차단되어야 함.

---

⛔ **기존 방식의 문제점**

- **공개키 방식 사용 불가능**
    - 기존 보안 기술(RSA 등)은 계산량이 많고 전력 소모가 커서 센서에 적합하지 않음.
- **모든 센서 간 키를 미리 설정하는 방식**
    - 센서 수가 많아질수록 필요한 키 개수가 폭발적으로 증가함.
    - 센서 하나에 너무 많은 키를 저장해야 하며, 이는 메모리 용량을 초과함.
    - 하나의 센서가 탈취되면 해당 센서가 가진 키와 연결된 모든 통신이 위험해짐.

→ 제한된 자원을 갖는 DSN 환경에서 **효율적인 키 관리**와 **상황별 보안 요구 대응**을 동시에 만족하는 스킴 설계하고자

---

✅ **제안 방식: 무작위 키 분배 기반 키 관리 체계**

- **핵심 개념**
    - 센서에 소수의 키만 무작위로 저장하고, 센서들 간에 **일부만 키를 공유**하도록 설계
    - 반드시 모든 센서가 직접 연결될 필요X, **중간 경로를 통해 간접 연결**해도 충분
    - 연결 구조는 센서들이 **임의로 키를 공유하는 구조**로 구성됨.

---

✅ **프로토콜 구조 및 기능**

**1. 키 사전 분배 (Key Pre-distribution)**

- 전역 키 풀 P 생성 후, 각 노드에 무작위로 k개의 키를 선택하여 저장 (key ring 구성)
- 각 노드는 자신의 키 식별자(ID)만 저장
- 컨트롤러는 각 노드의 키링 정보를 보관
- 노드 간 공유 키 존재 여부는 확률적이며, 키 사전분배는 오프라인에서 수행

**2. 공유 키 탐색 (Shared Key Discovery)**

- 초기화 시, 이웃 노드와 키 식별자 리스트를 교환하여 공유 키 여부 확인
- 키 식별자는 평문으로 교환하되, 공격자는 어차피 해당 노드를 탈취하면 키를 알 수 있으므로 위험 증가 없음

**3. 경로 키 설정 (Path Key Establishment)**

- **직접 공유 키가 존재**할 경우 → 링크 단위 보안 통신 가능
- **공유 키가 없을 경우** → 공유 키 경로를 따라 **path key 설정**으로 간접 보안 경로 생성
- 키링에는 항상 여분 키 공간이 존재하도록 설계되어, 재키잉 및 노드 추가 대응 가능

---

✅ **보안 기능 및 확장성 대응**

**키 폐기 (Key Revocation)**

- 탈취된 노드의 키링 내 키 식별자를 컨트롤러가 서명하여 브로드캐스트
- 각 노드는 서명 검증 후, 일치하는 키를 삭제
- 폐기된 키는 전체 키 풀 중 일부에 불과하므로 영향이 국소적임

**재키잉 (Re-keying)**

- 키 수명 만료 또는 상태 이상 시, 해당 키를 제거하고 공유 키 탐색/경로 키 설정 단계 재수행

**노드 포획 대응 (Resilience to Node Capture)**

- 단일 노드가 포획되어도, 그 노드의 키 kkk개만 노출되며 전체 키 풀 PPP와 비교하면 노출 확률은 kP\frac{k}{P}Pk
- 키 재사용률이 낮고, 대부분의 키가 1~2개의 링크에만 사용됨 → 피해 범위 제한

---

📈 **설계 특징**

**메모리 효율성**

- 센서에 저장되는 키 개수가 작으므로, 적은 메모리만으로도 보안 기능 유지 가능.

**보안성**

- 키를 공유하는 센서가 제한되어 있어, 하나의 키가 유출되더라도 관련된 연결만 영향을 받음.

**확장성**

- 새로운 센서를 쉽게 추가하거나 기존 센서를 제거할 수 있음.
- 복잡한 재설정 없이 기존 구조를 유지한 채 동작 가능.

---

💡 **기여**

- 센서 환경에 적합한 **가볍고 단순한 키 관리 방식** 설계.
- **무작위 키 공유 구조**를 통해 보안성과 확장성을 동시에 달성.
- 키 제거, 재설정, 노드 추가/삭제 등 **동적 환경에서의 유연한 대응** 가능.

### 수식 이해: **랜덤 그래프 기반 연결성 분석**

**✅ 연결성을 왜 수학적으로 분석할까?**

분산 센서 네트워크(DSN)는 수천~수만 개의 노드로 이뤄짐. 이 노드들이 서로 통신하려면:

- 최소한 **서로 연결되어 있어야** 하고,
- 적어도 대부분의 노드가 **어떤 경로로든 다른 노드에 도달 가능**해야 합니다.

하지만 모든 노드가 직접 연결되는 건 **불가능하거나 비효율적**입니다. 그래서 논문에서는 다음과 같은 질문을 던집니다:

> "노드들에 키를 무작위로 배포했을 때, 네트워크 전체가 끊기지 않고 연결되려면 키를 몇 개씩 배포해야 할까?"
> 

---

**✅ 랜덤 그래프란?**

- 네트워크 전체를 하나의 "그래프"라고 보면, 노드는 점(정점), 연결은 선(간선)입니다.
- 랜덤 그래프는 말 그대로 **임의로 연결된 그래프**입니다.
    - 즉, "각 노드 쌍이 연결될 확률이 일정한 그래프"
- 이 연결 확률을 pp라고 하면:
    - pp가 클수록 더 많이 연결되고
    - pp가 작을수록 네트워크가 **조각**(disconnected components)으로 나뉠 수 있습니다.

---

**✅ 논문에서의 적용: 키 공유 → 연결**

- 두 노드가 **공통된 키를 하나 이상** 갖고 있을 때만 보안 연결 가능
- 그래서:
    - "두 노드가 연결될 확률 pp" = "두 노드가 키를 공유할 확률"
- 이 확률은 다음 요인에 따라 달라짐:
    - 키 풀 전체 크기 PP
    - 한 노드가 보유하는 키 수 kk
    - 두 노드가 **서로 겹치는 키를 가질 확률**

---

**✅ 얼마나 많은 키가 필요할까?**

직관적으로 생각해봅시다:

- 키 풀 PP가 10,000개이고, 각 노드에 10개만 저장하면:
    - 두 노드가 같은 키를 가질 확률은 매우 낮음 → 연결 거의 안 됨
- 반대로 각 노드에 1,000개씩 저장하면:
    - 키 중복 확률 증가 → 많은 노드가 서로 연결됨

그래서 논문에서는 다음 목표를 설정합니다:

> "노드가 평균적으로 주변 노드와 몇 개나 연결되면, 전체 네트워크가 거의 확실히 연결된다고 볼 수 있을까?"
> 

이걸 도와주는 것이 **랜덤 그래프 이론**입니다.

---

**✅ 핵심 결과 요약 (수식 없이 이해)**

- **노드 수가 많아질수록**, 완전 연결을 위해 필요한 **노드당 평균 연결 수**는 **조금만 늘어나면 충분**합니다.
    - 예: 노드 수가 1,000 → 10,000으로 증가해도, 평균 연결 수는 20~30 정도만 확보되면 거의 확실히 연결됨
- **키링의 크기 k**가 클수록 → 더 많은 노드와 키 공유 가능 → 연결 확률 증가

---

**✅ 예시로 이해하기**

논문 속 실제 예:

- 노드 수: 10,000
- 키 풀 크기: 100,000
- 키링 크기: 250개
- 결과: 네트워크 전체가 거의 확실히 연결됨 (연결 확률 99.999%)

즉, **키를 250개만 저장해도**, 10,000개 노드가 잘 연결된다는 뜻!

---

**✅ 요약**

| 항목 | 의미 |
| --- | --- |
| 키 풀 P | 전체 키의 집합 (공유 가능한 후보 키들) |
| 키링 k | 한 노드가 갖는 키 수 |
| 연결 확률 p | 두 노드가 키를 공유할 확률 (그래서 연결될 확률) |
| 평균 연결 수 d | 한 노드가 평균적으로 연결되는 이웃 수 |
| 연결성 확보 조건 | kk와 PP를 적절히 정하면, 노드가 완전 연결되지 않아도 전체 네트워크는 대부분 연결됨 |

---

필요하시다면 위 내용을 본문 정리(#5 실험 결과, #4 아이디어 등)에 반영해서 통합해드릴 수 있습니다!

## #5. 실험 설계 및 결과 해석

- **실험 구성**
    - $$ n=1,000 $$ 노드
    - 평균 이웃 수 = 40
    - 키링 크기 $$ k $$와 키 풀 크기 $$ P $$ 변화 → 연결성 및 경로 길이 측정
- **주요 실험 결과**
    - **경로 길이**: $$ k $$ 증가할수록 **평균 경로 길이 감소**
        
        → $$ k=75 $$ 이상이면 대부분의 노드 간 1~3 홉 이내 통신 가능
        
    - **링크 키 공유 비율**: 전체 키 풀 중 **절반 이하만 사용됨**
        
        → 하나의 키가 여러 링크에 사용될 확률 낮음 → 포획 시 피해 최소화
        
    - **노드 포획 시 영향**: $$ k=250 $$, $$ P=100,000 $$ → 한 노드 포획 시 **전체 링크 중 0.25%만 노출**
    - **연결성 확보 조건**:
        - $$ n=10,000 $$, $$ P=100,000 $$에서 $$ k=250 $$이면 **99.999% 연결 확률 확보**

## #6. 한계점 및 개선 방향

- ⛔ **키링 구성 무작위성에 따른 연결 불균형 가능**
    - 어떤 노드는 이웃들과 거의 공유 키 無 → 초기 연결 시 병목 발생 우려
- ✅ **개선방안**: **키링 구성 시 통신 범위 기반 부분적 편향 도입**
    
    → 통계적으로 주변 이웃과 공유 키 개수 보장하도록 설정 可
    

---

- ⛔ **공유 키 발견 시 식별자 전체를 평문 전송**
    - 적 공격자에게 **트래픽 분석 기회 제공**
- ✅ **개선방안**: 공유키 탐색 시 암호화 챌린지/응답 기반 프로토콜 활용
    
    → 식별자 노출 최소화, 은닉성 보장
    

---

- ⛔ **키 폐기 후 경로 재설정 비용 존재**
    - 노드 포획 후 재키 설정 과정 → 에너지 소비 증가, 통신 지연 발생
- ✅ **개선방안**: 경로키 예비 설정 및 부분적 로컬 키 교체 방식 고려
    
    → 폐기 영향 최소화 + 빠른 복구 가능
    

---

- ⛔ **공격자가 키링 구조를 분석할 수 있는 통계학적 공격 가능**
    - 일부 키가 반복 사용될 경우 → 키 유사도 기반 공격 위험
- ✅ **개선방안**: 키링 내 키들 간 **의도적 중복 최소화**, 키풀 정기 재구성 방식 고려

---

🧩 **한 줄 요약**:

**확률 기반 구조의 연결성과 보안성 확보라는 큰 장점에도 불구하고, 탐색 은닉성 부족 및 연결 불균형 문제는 추가 개선 여지 존재**

## #7. 문제-해결 요약 정리

- ⛔ **공개키 방식 사용 불가능**
    - 센서 노드 자원 부족 → RSA 등 공개키 연산 에너지 과다 소모
- ✅ **대칭키 기반 사전 분배 방식 채택**
    - 연산 단순 + 전력 소비 적음

---

- ⛔ **노드 수 증가 시 저장 용량 문제**
    - 기존 방식은 노드당 $$ (n-1) $$개의 키 저장 요구 → 메모리 과부하
- ✅ **확률 기반 키링 구성으로 저장 효율 확보**
    - $$ k=100 $$~$$ 250 $$ 개만 저장해도 네트워크 전체 연결 확보 가능

---

- ⛔ **노드 포획 시 전체 키 노출 위험**
    - 단일키 또는 전체 쌍별 키 방식은 한 노드 노출 → 전체 시스템 위험
- ✅ **부분 키만 노출되는 구조 설계**
    - 키링 내 일부 키만 손실 → 전체 네트워크 피해 최소화

---

- ⛔ **동적 노드 추가/삭제, 재키 설정 어려움**
    - 전통적 방식은 노드 변경 시 전체 재키 필요 → 과도한 통신/연산 요구
- ✅ **경량화된 경로키 설정 및 부분 재분배 설계**
    - 변경된 노드만 처리 → 유연한 네트워크 운용 가능

---

📌 **한 줄 요약**:

**저장 효율성과 연결성을 동시에 달성하며, 센서 네트워크 환경에 맞춘 실용적 키 관리 체계를 확립**

# 논문 분석

## 1. INTRODUCTION

**Distributed Sensor Networks (DSNs)의 특성**

- **ad-hoc mobile network**: 센서 노드는 계산 및 통신 능력이 제한됨.
- **동적인 특성**: 배치 이후에도 센서 노드를 추가/삭제O
- **적대적 환경**에 배치될 수 있음: 통신 도청, 노드 탈취 등의 보안 위협 존재

---

**DSNs의 보안 요구사항**

- DSNs가 요구하는 보안기능:
    - **Cryptographic protection of communications** (통신 암호화 보호)
    - **Sensor-capture detection** (노드 탈취 감지)
    - **Key revocation** (키 폐기)
    - **Sensor disabling** (노드 비활성화)

---

**제안된 Key-Management Scheme**

- DSNs의 **운용성+보안 요구사항**을 **동시에 충족**하기 위한 key-management scheme을 제안.
    - **Selective distribution and revocation of keys** (선택적 키 배포 및 폐기)
    - **Node re-keying** (노드 재키잉)
    - 센서 노드의 연산·통신 능력을 크게 요구하지 않음
- **기술적 핵심: Probabilistic Key Sharing**
    - **Random graph 기반 확률적 키 공유(probabilistic key sharing)**에 기반.
    - 주요 프로토콜:
        - **Shared-key discovery**(공유 키 탐색)
        - **Path-key establishment**(경로 키 설정)
        - 키 폐기, 재키잉, 노드 추가 등을 위한 간단한 프로토콜 사용
- **성능 분석**
    - 제안된 스킴이 제공하는 **보안성과 네트워크 연결성 특성**을 분석.
    - 시뮬레이션을 통해 **성능을 실증적으로 평가**.

## **5. CONCLUSIONS**

- **간단하면서도 확장 가능한 키 관리 체계 제안**
    - 제안된 스킴: 센서 노드는 자원이 제한 → **구현이 매우 단순(simple)**한 구조로 설계
- **확장성과 유연성 제공**
    - **센서 메모리 사용량과 네트워크 연결성 간의 trade-off**를 허용
    - **운용 환경에 따라 파라미터 조정이 용이**함.
- **기존 key pre-distribution schemes 대비 우수함 입증** with 분석 및 시뮬레이션

## 1. Introduction

### DSNs(분산 센서 네트워크)의 특성

- **공통점 (vs. 전통적인 Embedded Wireless Networks)**
    - 배터리 기반 센서 노드, 제한된 연산·메모리 자원
    - 무선 통신(RF/광통신), 데이터 수집 및 제어 노드 존재
    - 대부분의 노드는 비이동성, 일부는 고이동성
- **차이점**
    - **대규모 (tens of thousands)** 센서 구성
    - **동적 구성 (dynamic)**: 배치 후에도 노드 추가/제거 가능
    - **적대적 환경 배치**: 감청, 노드 탈취 가능성 존재
        
        → DSN은 **복잡한 보안 요구사항** 발생
        

---

### 📌 DSN 환경에서의 보안 제약

### Communication Security Constraints(통신 보안 제약)

- 센서 성능 범위 다양: Smart Dust 수준(8KB/512B)부터 MIPS 급 고성능까지
- **Public-key cryptosystems(비대칭키 기반 암호화)**는 비효율적
    - 예: RSA(1024-bit) 서명 = 840mJ, AES(1024-bit) = 0.104mJ
    - 장거리 전송보다 RSA 연산이 더 많은 에너지 소모
    - 거리의 제곱에 비례해 통신 전력 증가 → 근거리 통신 시 에너지 절약 효과 큼

→ 결론: **symmetric-key ciphers + authenticated encryption + hash functions**가 현실적인 대안

### Key Management Constraints (키 관리 제약)

- **전통적 키 교환 방식의 한계**:
    - 인터넷 기반 PKI 구조는 DSN에 부적합
        - P) 네트워크 토폴로지를 **사전 파악 불가**
        - P) 통신 범위 제한, 노드 동작 불연속성, 네트워크 동적 변화 존재
            
            → 기존의 TTP 기반 키 관리 구조는 **DSN에 현실적으로 적용 불가**
            
- **S) Key Pre-distribution 방식**
    - 배포 전, 각 센서노드에 키 pre-분배
    - 목적: 배포 이후 노드 간 **보안 연결성 확보**
    - P) 전통적인 키 사전 분배
        
        
        | 방식 | 설명 | 문제점 |
        | --- | --- | --- |
        | **P1) Single mission key** | 하나의 키를 전체 노드에 공유 | 하나만 탈취돼도 전체 네트워크 compromise(손상) |
        | **P2) pair-wise private key sharing** | -각 노드가 n-1개 키 보유 → 모든 다른 노드와의 1:1 공유 키를 사전에 저장
        -선택적 키 폐기 가능 → 한 노드 탈취 시 전체 네트워크 손상 없이 국지적 대응 가능 | 저장 공간 초과 (RAM 약 80KB 필요), 노드 간 통신 거리 제한, 노드 추가/삭제 시 복잡한 재분배 필요 |
        
        → DSN 규모에서는 **둘 다 비현실적**
        
- **S) Probabilistic key sharing 기반 key pre-distribution**
    
    **Our Approach: simple key pre-distribution scheme**
    
    - **key pre-distribution(P2급 보안성+운영 효율성+자원↓)**
        - 메모리 요구량: 센서 노드당, **수십~수백 개(key ring of size k) key**만 **저장** (cf. n-1)
        - 기본 원리:
            - **probabilistic key sharing**을 기반
            - **random graph** 구조 위에서 노드 간 키 공유 관계를 설정
            - **shared-key discovery protocol** for (key distribution, 키 폐기(revocation), node re-keying)
        - **키 관리 체계 구성(단계)**
            1. **Key Pre-distribution**: 센서에 무작위 k개 키 저장
            2. **Shared-key Discovery**: 이웃 노드 간 공유 키 탐색
            3. **Path-key Establishment**: 공유 키 없는 노드 간 중간 경로 통한 키 전달
    1. **Key Pre-distribution:** Key Ring 구성 + 초기 분배
        - **key pool**에서, **k개의 키를 무작위로 선택(=key ring)**하여 각 노드에 저장
            - P) 일부 노드 쌍: 직접 공유하는 키가 없을 可
            - S) **중간 노드를 통한 path**가 존재하면 간접적으로 **path-key establishment** 가능
                
                → 즉, **full shared-key connectivity**는 **필수X**
                
                → 전체 연결성(shared-key connectivity)은 **경로 기반 중개로 확보** (모든 노드 간 직접 공유 필요X)
                
        - 연결성 확보를 위한 파라미터 예시
            
            **Random graph 모델**을 기반으로, 연결성과 보안성을 수학적으로 분석
            
            - 노드 수 n = 10,000
            - 키 풀 크기 P = 100,000
            - key ring 크기 k = 250
                
                → 이 구성만으로도 **거의 확실한(shared-key connectivity)** 확보 가능
                
                → 여전히 **남은 키들이 존재**하므로 **네트워크 확장 여력도 충분**
                
        - 보안 관리 기능 포함
            - **Key revocation**: 특정 노드 키만 선별 제거可
            - **Node re-keying**: 노드 자체적으로 만료된 키 제거 후 재탐색 可
            - **Incremental addition/deletion**: 노드 추가·삭제에 유연하게 대응
        - 기존 연구와의 차이 (Related Work)
            
            
            | 기존 연구 | 한계점 |
            | --- | --- |
            | **Group communication** (e.g., k-user secure groups) | 메모리 제약 고려 부족, DSN에 비적합 |
            | **Broadcast encryption** (master-slave 모델) | DSN 구조에 부적절, 확장성 부족 |
        
        → 제안 방식: **대규모 DSN 환경에서 실용적+효율적**
        

## **2. OVERVIEW OF THE BASIC SCHEME**

### **2.1 Key Distribution**

- **키 관리 체계 구성(단계)**
    1. **Key Pre-distribution**: 센서에 무작위 k개 키 저장
    2. **Shared-key Discovery**: 이웃 노드 간 공유 키 탐색
    3. **Path-key Establishment**: 공유 키 없는 노드 간 중간 경로 통한 키 전달

---

**1️⃣ Key Pre-distribution**

- 배포 전에 오프라인에서 실행되는 **5단계 과정**:
    1. **Key pool(P)** 생성 (예: 2¹⁷ ~ 2²⁰개의 키)
    2. 각 센서 노드에 대해 **P 중에서 k개의 키 무작위 선택 (without replacement)**
    3. 선택된 키들을 **센서 노드 메모리에 저장**
    4. 해당 키들의 ID + 센서 노드 ID를 **controller node에 저장**
    5. 각 센서 노드는 **i번째 controller node와 공유할 키**를 별도로 계산하여 저장
- 예시: 공유 확률 0.5를 보장하려면, **10,000개 키 풀에서 75개만 노드에 탑재**하면 충분

---

**2️⃣ Shared-key Discovery**

- DSN 초기화 시, 각 노드는 **통신 범위 내 이웃 노드들과 공유 키 존재 여부 탐색**
- 기본 방식:
    - **자신의 키 ID 목록을 평문으로 브로드캐스트 (암호화 없이)**
    - 두 노드가 키 ID를 비교해 **공유 키 존재 여부 확인**
    - 공격자에게 새로운 이득은 없음 (노드를 탈취하면 어차피 키 확인 가능)
- 대체 방식(보안 강화 목적):
    - 목적: **누가 어떤 키를 갖고 있는지 외부에 노출되지 않도록**
    - 키 자체를 브로드캐스트(X)
    - `α`(각 키에 대한 랜덤한 challenge 값, 노드가 생성)를 만듦 → $$ E_{Ki}(α) $$ (Ki로 α를 암호화)형식으로 브로드캐스트
    - 수신 노드가 복호화에 성공하면 공유 키 확인
        
        
        | 기존 방식 | 대체 방식 |
        | --- | --- |
        | 키 ID 목록을 **평문**으로 전송 → **공격자가 보고 추정 가능** | 키 ID 자체는 숨기고, **암호문만 전송** → **공격자는 키를 모르면 정보 없음** |
        | 탈취하지 않은 노드도 **누가 어떤 키 갖고 있는지 추측 가능** | **복호화 성공한 노드만 공유 키 존재 여부 확인 가능** |
    - 예시
        
        **가정**
        
        - 센서 노드 **A**는 key ring으로 **{K₁, K₂, ..., Kₖ}**를 가짐
        - 노드 **B**는 자신의 key ring에 어떤 Ki를 포함하고 있는지 모름
        
        **A의 동작**
        
        1. 랜덤한 **challenge 값 α** 생성
        2. A는 자신의 각 키 Ki로 α를 암호화 → **`{E<sub>K₁</sub>(α), E<sub>K₂</sub>(α), ..., E<sub>Kₖ</sub>(α)}`** 생성
        3. A는 이 암호문 리스트와 α를 함께 **브로드캐스트**
        
        **B의 동작**
        
        1. 수신한 암호문 리스트 중, 자신의 key ring에 있는 어떤 키 $$ K_j $$로 **$$ E_{K_j}(α) $$**를 복호화 시도
        2. 복호화 결과가 α와 일치 → **B는 A와 키 Kj를 공유하고 있음**을 확인 → shared key 존재 판단
        
        **특징**
        
        - 키 ID를 공개하지 않고 **공유 여부만 확인** 가능
        - 공격자는 키를 알지 못하면 복호화 실패 → **트래픽 분석에 안전**
- 결과:
    - 두 노드가 **공유 키가 있는 경우에만 링크 형성**
    - 모든 통신은 **link encryption**으로 보호
    - 하나의 키가 여러 노드 간 공유될 수 있지만, **노드 탈취 시 키 ring만 폐기하면 영향 최소화**

---

**3️⃣ Path-key Establishment (경로 키 설정 단계)**

- **목적**:
    - **공유 키가 없는 인접 노드들 간의 보안 연결을 보완하는 단계**
    - 예시
        - 노드 A와 B는 인접하지만, key ring에 공유된 키 없음
        - 다만, A–C–B처럼 **중간 노드를 통해 간접적으로 연결되어 있음**
        - 이럴 때, 경로를 통해 새로운 공유 키(path-key)를 설정함
- **핵심 아이디어: 미사용 키의 재활용**
    
    Q. 왜 "미사용 키"가 생기는가?
    
    - 각 노드는 key ring에 k개의 키를 저장
    - 하지만 shared-key discovery 이후, 이 중 일부만 실제 통신 링크에 사용되고
        
        **많은 키는 어떤 노드와도 공유되지 않아 "남게 됨"**
        
    
    Q. 이 미사용 키를 어디에 쓰나?
    
    - A–B처럼 **공유 키가 없지만 연결이 필요한 노드 쌍**에 대해
        
        → **남은 키 중 하나를 새로운 path-key로 지정**하여 공유
        
    
    즉, “사용되지 않고 남아 있는 키”들을 **경로 기반 연결 회복 또는 노드 추가에 유용하게 재활용**
    
- 운영 유연성 확보: 키 폐기 및 노드 추가 대응
    - **키 폐기(revocation)** 시 → 노드 일부의 키가 제거되어 연결 단절될 수 있음
    - **노드 추가** 시 → 기존 노드와 공유 키가 없을 수 있음
    - 이럴 때마다 **path-key establishment 단계를 실행하여 연결 회복 가능**
    
    → 이를 위해 **key ring 크기 k**를 넉넉히 설정하면, 항상 **여분의 키를 확보 가능**
    

### **2.2 Revocation (키 폐기)**

- **상황 요약: "센서 노드가 탈취되었을 때 해야 할 일"**
    - 목적: **해당 노드의 key ring에 있던 키들을 모두 폐기**.
    - P) 그 키들을 다른 노드들도 일부 공유하고 있을 수O
    - S) **전체 NW에 “이 키들 더 이상 쓰지 마!”**라고 알려야
    - P) 악용가능성: 공격자가 ‘지워야할 키 리스트’를 구라(위조)칠 수도
    - S) **서명** → 노드가 진짜인 걸 확인한 다음에만 키 삭제

---

- **Revocation 방식: Controller-initiated signed list broadcast**
    
    **컨트롤러 노드:** 키 폐기를 주도함! 센서 노드를 **감시, 관리, 제어** (cf.센서노드)
    
    1. 폐기할 **key ID list** 생성
        - 탈취된 노드의 **key ring에 있는 $$ k $$개의 key identifier**를 리스트로 만듦
            - `[k1, k2, ..., kk])`: 더이상 이 키는 쓰지마라.
    2. **컨트롤러 노드: 서명(signature)** 수행
        - 서명할 키 보내야함. 어떻게?
            
            → 모든 노드는 컨트롤러와 공유하는 개별 키 $$ K_{ci} $$를 가지고 있음 → 컨트롤러는 서명용 키 $$ K_e $$ 생성 → **각 노드에 맞춰 암호화해 unicasting**으로 보냄 (not broadcast)
            
    3. **센서 노드의 동작**
        - $$ K_{ci} $$로 $$ K_e $$ 복호화 → 컨트롤러의 서명 검증
        - 자신의 key ring에 해당 key ID가 있는지 확인 → 있으면 삭제
    - **키 구분**
        
        
        |  | 종류 | 용도 | 통신 상대 |
        | --- | --- | --- | --- |
        | $$ K_{ci} $$ | **대칭키** | 컨트롤러 ↔ 센서 노드 간 **기밀 채널 구축** | 1:1 비밀 공유 |
        | $$ K_e $$ | **MAC 키** or **공개키** | 폐기 리스트에 대한 **서명 검증용** | 전체 센서 노드가 받음 |

---

- 폐기 효과 & 네트워크 반응
    - 폐기된 노드의 key ring이 제거 → 해당 노드의 **연결성 완전히 제거**
    - 폐기된 키를 공유했던 일부 다른 노드들의 연결도 영향을 받을 수 있음
        - 영향받은 노드들: **shared-key discovery & path-key establishment를 재수행**하여 연결 복구 시도

---

- 설계상의 강점
    - 전체 키 풀($$ P $$) 중 **k개만 제거** → 다른 노드에는 **국지적 영향만 발생**
    - **네트워크 전체에 광범위한 재설정 불필요**

---

- 요약 (Revocation)
    
    
    | 항목 | 내용 |
    | --- | --- |
    | 대상 | 탈취된 노드의 key ring 전체 |
    | 주체 | controller 노드 |
    | 방식 | signed key ID list broadcast + unicasted signature key |
    | 노드 반응 | key ID 확인 후 삭제 → 필요한 경우 재설정 수행 |
    | 네트워크 영향 | compromised 노드는 완전 차단 + 다른 노드는 최소 영향 |

### **2.3 Re-Keying**

- **상황 요약**
    
    센서 노드가 **사용 중인 키의 유효기간이 만료**됨 → 오래된 키는 더 이상 쓰면 위험하니까 **스스로 폐기하고 새로 연결**해야 ← 일종의 **self-revocation**
    

---

- 재키잉 방식: 로컬 자율 수행
    1. **컨트롤러가 나서지X** → **노드가 혼자 알아서 처리**
        - 네트워크 전체 브로드캐스트 없이 **각 노드가 로컬에서 독립 수행**
        - 운영 간소화 + 통신 비용 절감
    2. **노드가 하는 일:**
        - 만료된 키(=유효기간이 지난 키) 삭제
        - 이후, 키가 끊긴 이웃 노드들과 다시 연결 시도 → **shared-key discovery & path-key 설정 재수행**

---

- **설계상의 강점**
    - 구조가 매우 단순, 전체 DSN의 동작에 부담 주지X
    - 자율적, 분산형 보안 유지 수단

---

- **정리 요약 (Re-keying)**
    
    
    | 항목 | 내용 |
    | --- | --- |
    | 트리거 | 키 유효기간 만료 |
    | 주체 | 해당 노드 (자체 처리) |
    | 동작 | 키 삭제 후 → 재탐색 및 재연결 수행 |
    | 특징 | 컨트롤러 개입 없음 + 네트워크 전체 재설정 불필요 |

### **2.4 Resiliency to Sensor-Node Capture (센서 노드가 공격자에게 탈취될 경우를 대비한 복원력)**

- **왜 중요한가?**
    - 센서 노드는 **적대적인 환경(hostile areas)에 혼자 놓여있음 → 물리적으로 공격자에게 sensor-node capture(탈취) 可**
    - 단순한 키 유출을 넘어 → DSN 전체 보안 메커니즘에 영향을 미침

---

**🔍 위협 수준(Levels of Threat)**

**1️⃣ 데이터 조작 수준 (소프트 공격)**

- 물리적으로 센서를 파괴하진 않아도, 공격자가 **센서의 입력값을 조작 → 거짓 데이터를 퍼뜨리는 것**
    - 예: 센서가 “30도다”라고 보내야하는데 공격자가 “100도다”라 조작
- **탐지 어려움**
    - 평소처럼 통신 → **이상 행동 탐지 기법으로는 안 잡힘**
    - 위성/드론 감시로 판별 불가
- **탐지 방법 (가능은 함)**
    - 다른 센서와의 데이터 비교 → **데이터 이상 탐지(data anomaly detection) /  Data correlation**
        
        **→** 단, **센서 밀도(density)가 높아야 함** (여러 센서가 같은 지역 감시 중일 때만 가능)
        

---

**2️⃣ 물리 탈취 수준 (하드 공격)**

- 공격자가 센서를 통째로 **물리적으로 장악**한 상태 → 센서 내부 키, 기능, 통신 등 **모든 권한을 가짐**
- 추가 위협 예: **Sleep-deprivation Attack**
    - 탈취한 노드: **공유 키가 있는 다른 노드에게 과도한 통신** 보냄 → **배터리를 소모 → 기능 정지 유도**

---

- **방어 방법: Tamper-detection 기술**
    - 센서 하드웨어 내부에 **감지 장치**를 두는 방식
        - 누군가 **센서를 물리적으로 열려고 하면**, 자동으로 **key ring을 삭제 + 센서 작동 중단**
    - 추가 설계 예:
        - key ring을 **별도의 암호화 키로 감싸기(key-encrypting key)**
        - 이 키만 빠르게 지워도 **전체 키 삭제 효과** 얻을 수 있음

---

- **제안 방식의 강인성 비교**
    
    
    | 키 분배 방식 | 노드가 탈취되었을 때 피해 범위 |
    | --- | --- |
    | **Single mission key** | 전체 네트워크 완전 손상 |
    | **Pair-wise key sharing** | **n-1개 링크 노출** (해당 노드와 연결된 모든 노드) |
    | **제안된 스킴** | **오직 key ring 안의 k개 키만 유출 → 다른 링크에 대한 공격 확률 ≈ k/P** |
    - 공격자는 **전체 DSN 연결 중 아주 일부**만 건드릴 수 있음
    - **controller와의 공유 키**도 유출 가능하지만,**다른 센서 노드에는 영향x**
    - 물리적 탈취에도 높은 탄력성(resiliency)

---

- **핵심 요약**
    
    
    | 항목 | 내용 |
    | --- | --- |
    | 위협 1 | 센서 입력값 조작 (감지 어려움, 데이터 비교로 탐지 가능) |
    | 위협 2 | 센서 물리 탈취 (완전 권한 획득, 배터리 소모 공격 가능) |
    | 방어 방식 | Tamper-detection → 센서 열면 키 삭제 + 기능 정지 |
    | 기존 방식의 한계 | 하나만 뚫려도 전체 네트워크 유출 가능 (특히 mission key 방식) |
    | 제안 스킴의 장점 | 공격자가 얻는 키 수 매우 제한적 (k/P 확률) + 영향은 해당 노드에 국한됨 |

## **3. ANALYSIS**

### **3.1 DSN Connectivity with Random Graphs**

- **왜 이걸 다루는가?**
    - 센서 노드가 무작위로 배치된 DSN에선, **모든 노드 간 완전 연결(full shared-key connectivity; shared-key 직접 보유)**될 필요X
    - 대신, **무작위 연결(random graph)** 속성을 이용 → 네트워크 전체가 **간접 연결만으로도 충분히 연결성(connectedness)**을 가질 수O

---

- **핵심 아이디어**
    - “shared-key discovery만으로 네트워크 전체가 연결되게 하려면, 각 노드에 얼마나 많은 키를 배포해야 할까?”
    
    ↓ 구체화된 세부 질문
    
- DSN shared-key connectivity를 establish 위한 질문 2가지
    1. **몇 개의 키를 각 노드에 넣어야**, 전체가 연결되도록 보장할 수 있는가?
        
        즉, 그래프 G(n, p)가 확실히 연결(연결될 확률이 Pc ≥ 0.99)가 되기 위한 **p가 얼마이상이여야 할까? 즉, p의 임계값(threshold function**은?
        
    2. **센서의 통신 범위나 배터리 등 제약(neighborhood(n′))을 고려할 때**, 키 풀 크기($$ P $$), key ring 크기 ($$ k $$)는 어떻게 결정되어야 하는가?
        
        즉 센서 노드가 가진 **키 ring 크기 𝑘**와 **전체 key pool 크기𝑃**로
        → 그 **𝑝**를 실제 구현상 어떻게 맞출 수 있는지를 계산
        
    
    ```tsx
    1. 전체 네트워크 연결 조건 설정
       ↳ 원하는 연결 확률: P_c ≥ 0.99
       ↳ 이걸 만족하려면? → p ≥ threshold (e.g., p ≥ ln(n)/n)
    
          ↓ (p값 확보)
    
    2. 그 p값이 나올 수 있도록 파라미터 조정
       ↳ 각 노드에 몇 개 키(k)를 배포해야?
       ↳ 전체 키 풀(P)을 얼마나 크게 가져가야?
    ```
    

---

**🔍 문제 1: Random Graph 이론에 따른 연결 조건**

- **G(n, p)**:노드 n개가 있고, 두 노드가 연결될 확률이 p인 랜덤 그래프
    - 예: n=100이면, 각 노드 쌍은 p의 확률로 연결됨
    - 완전히 연결되었다 = 어떤 두 노드도 경로를 통해 서로 도달 가능 = shared key를 가짐
    
- **Erdős–Rényi 모델의 핵심 아이디어**
    - 랜덤 그래프 G(n, p)가 **"거의 확실하게(확률적으로) 연결되었다"**고 말하려면 p가 어느 정도 이상이어야. 그 조건이 다음 수식:
        
        $$ p = \frac{\ln(n)}{n} + \frac{c}{n} $$      n:전체 노드수, c:원하는 연결 확률 수준에 따라 달라지는 상수
        
    - 이 조건일 때, 이때, **그래프가 연결될 확률**
        
        $$ P_c = Pr[G(n, p) \text{ is connected}] =e^{−e^{−c}} $$
        
    - $$ c $$가 커질수록 → 연결될 확률이 1에 가까워짐
    - 예: c=11.5이면, 연결 확률≈0.99999
    
- 평균 연결 차수 (Expected degree)
    
    $$ d=p⋅(n−1) $$
    
    - d: 한 노드가 평균적으로 몇 개의 다른 노드와 연결되어 있는지를 의미해요.
        - d값이 너무 작으면 → 연결이 끊기고,
        - d가 너무 크면 → 메모리 낭비 (불필요한 키 저장)
    
    → **이 논문은 적당한 d만 확보해도 는 걸 보임**
    
    - 노드당 평균 연결 차수 $$ d = np $$가 **적절히 크면 →** 두 노드가 연결될 확률(p)이 **거의 1**(=전체 연결성이 충분히 높다, 네트워크는 거의 확실히 연결됨)
    
- **직관 요약**
    
    
    | 질문 | 답변 |
    | --- | --- |
    | 네트워크가 "거의 확실히 연결"되려면? | 두 노드 간 연결 확률 p가 $$ \frac{\ln(n)}{n} + \frac{c}{n} $$  이상이면 됨 |
    | 그럼 한 노드가 얼마나 많은 다른 노드와 연결되어야? | 평균적으로 $$ d=p⋅(n−1) $$정도 연결되면 충분 |
    | n이 커지면 d도 많이 커져야 하나? | ❌ 아님! 
    **d는 거의 일정** → **확장성 있음** (이 방식이 좋은 이유!!) |

- figure1: Expected Degree vs Number of Nodes (평균 연결 수d=p(n−1) 를 그래프로 시각화)
    
    ![image.png](/images/a-key-management-scheme-for-distributed-sensor-networks/image.png)
    
    **✅ 요약**
    
    - "네트워크가 전체적으로 끊기지 않고 연결되게 하려면, 각 노드는 평균적으로 **몇 개의 이웃 노드와 연결되어야** 할까?"
    
    **🔢 축 설명**
    
    - **x축**: $$ n $$ = 네트워크 내 **전체 센서 노드 개수**
        - 예: 1000개, 2000개, ..., 10000개
    - **y축**: $$ d $$ = 한 노드의 **기대 연결 차수** (Expected degree of node)
        - 예: d=15이면, 평균적으로 15개 노드와 연결
    - **곡선별 라벨**:   $$ P_c = \Pr[G(n,p)\text{ is connected}] $$
        - 그래프가 연결될 확률
        - 파란선 = 연결 확률($$ \Pr $$)이 0.99999가 되도록 하려면 필요한 $$ d $$
    
    **💡 그림 해석: 핵심 메시지 3가지**
    
    1. **연결 확률이 높아질수록 더 높은 d가 필요하다**
        - 𝑃𝑐=0.99일 땐 d≈12
        - 𝑃𝑐=0.999999일 땐 d≈22
    2. **노드 수가 늘어나도 𝑑는 천천히 증가한다**
        - 네트워크 규모(=노드수)가 커져도↑ → d(=요구되는 연결 수, 연결유지비용)는 **거의 일정 → 확장성우수**
        - 예: 노드 수n가 1000 → 10,000으로 10배 늘어나도, d는 20→21~22 수준
    3. **연결 확률을 높이고 싶을수록 평균 연결 차수를 조금 더 확보해야 한다**
        - 하지만, 선형 증가가 아니라 **완만하게 증가함**

---

**🔍 문제 2: 키 공유 확률 기반으로 P 계산**

- **목표 질문**:
    - "내가 가진 키 링 크기 $$ k $$로, 이웃 노드와 어**느 확률로(shared-key probability  $$ p′ $$)** 키를 공유할 수 있을까?"
    - "그 확률을 만족하려면, 전체 키 풀 크기 $$ P $$는 얼마나 커야 할까?"
- 용어 정리
    
    
    | 기호 | 의미 |
    | --- | --- |
    | k | 한 노드가 가지는 키의 개수 (key ring size) |
    | P | 전체 키 풀의 크기 (전체에서 랜덤 선택) |
    | n’ | 한 노드가 무선으로 연결되는 이웃 노드 수 |
    | p’ | 이웃 노드 간에 **공유 키가 있을 확률** |
    | d | 평균 연결 차수 = 한 노드가 실제 연결된 노드 수 |

1. 이웃 간 키 공유 확률 ($$ p′ $$):
    - 무선으로 이웃하는 노드 수가 𝑛′개일 때, 실제로 연결된 노드 수가 𝑑면 → 공유 키가 있을 확률:
        
        $$ p' = \frac{d}{n' - 1} $$
        
2. 두 노드가 **공유 키를 가질 확률**은?
    - 각 노드가 key pool(𝑃) 中 key 𝑘개를 무작위로 골랐을 때 → 두 노드가 공유 키를 하나도 안 가질 확률:
        
        Pr[No shared key] = $$ \frac{(P - k)!^2}{(P - 2k)! \cdot P!} $$
        
    - → 그러면 공유 키가 **적어도 하나는 있을 확률**은:
    $$ p' = 1 - \frac{(P - k)!^2}{(P - 2k)! \cdot P!} $$
3. **계산을 쉽게 하려고 근사하기**:
    - 팩토리얼 연산이 복잡해서, 수학적으로 **Stirling 근사(Stirling’s approximation)**를 적용:
        
        $$ p' \approx 1 - \left(1 - \frac{k}{P}\right)^{2(P-k+1/2)} \cdot \left(1 - \frac{2k}{P} \right)^{-(P - 2k + 1/2)} $$
        

---

- 요약
    
    
    | 개념 | 설명 |
    | --- | --- |
    | Random Graph | 각 노드가 어떤 노드와 연결될지 무작위로 정해짐 |
    | $$ P_c $$ | 전체 네트워크가 연결될 확률 |
    | $$ k, P $$ | key ring 크기, 전체 key pool 크기 |
    | $$ k $$ 증가 | 두 노드가 공유 키를 가질 확률 $$ p’ $$ 증가 |
    | $$ P $$ 증가 | 공유 키 확률 𝑝’ 감소 → 더 많은 키가 필요 |
    | 핵심 목표 | key ring을 적절히 잡아 → 전체 DSN 연결성 확보
    = 원하는 𝑝′를 달성하려면, 𝑘와 𝑃 사이의 관계를 계산해야 |

---

- 예시
    - 목표: 이웃 노드와 공유 키 확률  $$ p′=0.5 $$
    - 주어진 것: $$ P=10,000 $$    P:key pool
    - 계산 결과:각 노드의 key ring에 $$ k = 75 $$개의 키 배포(저장)하면 충분
        
        → 전체 네트워크가 거의 확실히 연결
        

---

- figure2**: 공유 키 확률 vs 키 링 크기**
    
    ![image.png](/images/a-key-management-scheme-for-distributed-sensor-networks/image%201.png)
    

**✅ 요약**

- "노드가 키 𝑘개를 저장했을 때,두 노드가 **적어도 하나의 키를 공유할 확률 𝑝′**은 얼마나 될까?"

**🔢 축 설명**

- **x축**: k = 한 노드에 저장된 키 개수 (key ring size)
- **y축**: 두 노드가 **공유 키를 가질 확률**
    
    $$ p' = \Pr[\text{at least one shared key}] $$
    
- **곡선**: 키 풀 크기 $$ P $$ = 1,000 / 2,000 / 5,000 / 10,000 / 100,000

💡 해석 요점

1. k↑ → p′↑: **키 링 크기 k**를 늘릴수록 공유 확률 p′은 증가
- 한 노드에 **더 많은 키를 저장**하면 → **다른 노드와 공유할 확률도 증가**함
1.  **키 풀 $$ P $$**가 클수록 → 같은 공유 확률을 얻으려면 **더 많은 $$ k $$** 필요
    - 예:
        - P=10,000P: k=75일 때 p′≈0.5
        - P=100,000: 같은 p′을 얻으려면 k=250필요
    - 즉, 전체 키 풀이 커지면 두 노드가 우연히 같은 키를 고를 확률이 낮아짐
    → 그만큼 노드당 더 많은 키를 저장해야 공유 확률 확보 가능
2. 하지만 **P 증가에 비해 k 증가폭은 “완만”** → 여전히 메모리 효율적
    - 예: 공유 확률 p′≈0.5를 목표로 할 경우
        - P=10,000: k≈75
        - P=100,000: k≈250
    - 키 풀이 10배 커졌는데, k는 **약 3배만 증가** → **메모리 효율 유지 가능**

**📌 왜 이게 중요한가?**

이 그림은 설계자가 이런 질문에 답할 수 있도록 도와줌:

> "공유 확률을 p′=0.5 정도로 만들고 싶은데,
> 
> 
> 전체 키 풀 P=10,000이라면,
> 
> **각 노드에 키를 몇 개 저장**해야 할까?"
> 

→ 이때 답: k=75면 충분함!

### **3.2 An example** – 숫자 예제로 보는 스킴 작동 방식

- 목표: "DSN 전체가 연결되도록 키 파라미터를 설정하고 싶은데, 어느 정도가 적당할까?"

---

- 조건 가정
    - **노드 수**: $$ n=10,000 $$
    - **원하는 연결 확률**: $$ P_c = 0.99999 $$ (→ **거의 확실한 연결**)
    - **한 노드가 커버하는 이웃 수(n')**: 40 (통신 범위 내 노드 수)

---

- 1단계: 이론적 연결 조건 도출
    - **Erdős–Rényi 모델** 기반, **연결에 필요한 평균 차수 $$ d $$**는:
        
        $$ d=c=ln⁡(n)+γ≈11.5 $$ ($$ γ $$:보정상수) $$ d = c = \ln(n) + \gamma \approx 11.5 \quad $$ ($$ \gamma $$: 보정 상수)
        
    - 이때 필요한 **연결 확률 p**는:
        
        $$ p = \frac{d}{n} = \frac{11.5}{10,000} = 2 \times 10^{-3} $$
        

---

- 의미
    - "각 노드가 전체 중 20명 정도와만 연결돼도 네트워크는 거의 확실하게 연결된다"는 뜻.

---

- 2단계: 실제 키 파라미터로 환산
    - 위에서 구한 p=0.002를 만족하려면, **공유 키 확률 p′**도 이 수준이 되어야 함
    - 이때 **k=15, P=100,000**이면 p' = 0.002 만족
        
        → 즉, key ring에 15개만 넣어도 충분
        

---

- ⚠️ 그런데 현실에선 노드는 모든 노드와 통신할 수 없고,**자신 주변의 n′ = 40개 노드만 통신 가능** → 조건이 달라짐!
- 이때는 $$ p' = \frac{d}{n'-1} = \frac{20}{39} \approx 0.51 $$로 바뀜
    
    → **즉, 주변 이웃 39명 중 절반과는 키가 겹쳐야 한다는 뜻**
    

---

- 3단계: neighborhood 조건 만족하려면?
    - 같은 P=100,000P = 100,000 조건에서 → k = 250 정도 되어야 p′≈0.5 만족됨
    - neighborhood 크기를 늘려서 n′=60n′ = 60이 되면: $$ p' = \frac{20}{59} \approx 0.33 $$
        
        → 이 경우는 k = 200 정도면 충분
        

---

- 요약 정리
    
    
    | 항목 | 값 |
    | --- | --- |
    | 목표 | 전체 DSN 연결 확률 $$ P_c ≥ 0.99999 $$ |
    | 이론상 필요한 연결 확률 $$ p $$ | 2×10−32 × 10^{-3} |
    | 그걸 만족하는 최소 조건 | k=15, P=100,000 (이론 조건만 고려 시) |
    | 현실에서 이웃 노드 수 고려 시 | n′=40→ k=250, n′=60 → k=200 필요 |

---

- 핵심 포인트
    - **전체 연결만 고려하면 작은 k로도 충분**
    - 하지만 **이웃 노드 제한이 있는 현실적 통신 환경**에선 → k를 더 크게 잡아야 함 (key ring을 더 채워야 함)

## **4. SIMULATIONS**

**Simulation 목적 & 시뮬레이션 조건**

- **목적**
    - 다양한 파라미터가 **DSN의 효율성, 확장성, 보안성에 미치는 영향 분석**
- 조건
    - 노드 수: 1,000개
    - 이웃 노드 밀도(neighborhood): 평균 40개 노드
    - 시뮬레이션 반복: 서로 다른 시드로 10회 실행 → 평균값 사용

### **4.1 Effect on the network topology(Network Topology에 미치는 영향)**

- **공유 키 부재 → 링크 미존재**
    - shared-key discovery에서 **키가 공유되지 않은 노드 쌍은 네트워크 상 링크 없음으로 간주됨**
    - → 네트워크에서 두 노드 간 평균 경로 길이(average path length)가 증가할 수 있음
- **Key ring 크기(k)와 평균 경로 길이 관계**
    - key ring이 작을수록 → 공유 키 확률↓ → **연결 희박** → 평균 경로 길이 증가
    - **작은 k에서는 네트워크 단절 발생 가능**
- **Path-key 설정에 필요한 다중 링크 경로**
    - 이웃 노드와 공유 키가 없을 경우, **2~3개의 중간 링크(hops)**를 경유하여 path-key 설정
    - 이 경로는 **한 번만 사용**되므로 설정 비용은 **무시 가능 수준**
- **구체적 결과 예시**
    - k = 75 → 절반의 이웃 노드와 직접 연결 가능, 나머지는 3-hop 이내
    - k = 50 → 1/3만 직접 연결 가능, 나머지는 4-hop 이내로 연결 가능

### **4.2 Effect of an Attack against Unshielded Sensor Nodes (공개된 노드에 대한 공격 영향 분석)**

- **가정**: 노드가 물리적으로 탈취되어도 공격자는 해당 노드의 **k개 키만** 획득
- **키 사용 분포 관찰 결과**:
    - 전체 키 풀(P=10,000) 중 50%만 링크 보안에 사용
    - 30%의 키: 1개 링크 보호
    - 10%의 키: 2개 링크 보호
    - 5%의 키: 3개 링크 보호
- **결론: 공격 확산 가능성 낮음**
    - 하나의 키가 탈취되더라도, **다른 링크에 미치는 영향은 확률적으로 제한적**
        - 예: 30% 확률로 1개 추가 링크, 10% 확률로 2개 추가 링크가 노출될 수 있음

✅ 종합 해석

- **경로 설정 비용은 작고, 보안성은 강건함**
    - 작은 key ring으로도 전체 네트워크 연결 가능 (다중 hop 활용)
    - 노드 탈취가 일어나도, 키 풀의 분산 사용 구조 덕분에 **전체 보안 영향은 지역적**
- **스킴의 확장성과 효율성 입증**
    - key pool 관리 전략과 key ring 크기 조절만으로도, 실질적인 연결성과 보안성을 달성 가능